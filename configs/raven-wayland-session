#!/bin/sh
set -eu

export PATH=/bin:/sbin:/usr/bin:/usr/sbin

LOGFILE="/run/raven-wayland-session.log"
SERIAL="/dev/ttyS0"
mkdir -p /run 2>/dev/null || true
printf '' >"$LOGFILE" 2>/dev/null || true

log() {
    printf '%s\n' "$*" | tee -a "$LOGFILE"
    # Also log to serial console if available
    [ -c "$SERIAL" ] && printf '%s\n' "$*" > "$SERIAL" 2>/dev/null || true
}

export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/0}"
_old_umask="$(umask)"
umask 077
mkdir -p "$XDG_RUNTIME_DIR" 2>/dev/null || true
umask "$_old_umask"

export LIBSEAT_BACKEND="${LIBSEAT_BACKEND:-seatd}"
export RUST_BACKTRACE="${RUST_BACKTRACE:-1}"
export FONTCONFIG_PATH="${FONTCONFIG_PATH:-/etc/fonts}"
export FONTCONFIG_FILE="${FONTCONFIG_FILE:-/etc/fonts/fonts.conf}"
export XCURSOR_PATH="${XCURSOR_PATH:-/usr/share/icons}"
if [ -z "${XCURSOR_THEME:-}" ]; then
    if [ -d /usr/share/icons/breeze_cursors ]; then
        export XCURSOR_THEME=breeze_cursors
    elif [ -d /usr/share/icons/Adwaita ]; then
        export XCURSOR_THEME=Adwaita
    fi
fi

# Xwayland expects /tmp/.X11-unix to exist (it may not create the parent dir).
mkdir -p /tmp/.X11-unix 2>/dev/null || true
chmod 1777 /tmp /tmp/.X11-unix 2>/dev/null || true
rm -f /tmp/.X11-unix/X0 2>/dev/null || true

# Help libxkbcommon find keyboard layouts on minimal images.
# Some builds expect /usr/share/xkeyboard-config-2; others use /usr/share/X11/xkb.
if [ ! -e /usr/share/xkeyboard-config-2 ] && [ -d /usr/share/X11/xkb ]; then
    ln -sf X11/xkb /usr/share/xkeyboard-config-2 2>/dev/null || true
fi
if [ -z "${XKB_CONFIG_ROOT:-}" ]; then
    if [ -d /usr/share/xkeyboard-config-2 ]; then
        export XKB_CONFIG_ROOT=/usr/share/xkeyboard-config-2
    elif [ -d /usr/share/X11/xkb ]; then
        export XKB_CONFIG_ROOT=/usr/share/X11/xkb
    elif [ -d /usr/share/xkeyboard-config ]; then
        export XKB_CONFIG_ROOT=/usr/share/xkeyboard-config
    fi
fi

cmdline="$(cat /proc/cmdline 2>/dev/null || true)"
wayland_choice=""
for arg in $cmdline; do
    case "$arg" in
        raven.wayland=*)
            wayland_choice="${arg#raven.wayland=}"
            break
            ;;
    esac
done

start_seatd() {
    # Check if seatd is already running
    if [ -S /run/seatd.sock ]; then
        log "seatd already running"
        return 0
    fi

    if command -v seatd >/dev/null 2>&1; then
        log "Starting seatd..."
        # Run seatd with video group access
        seatd -g video >>"$LOGFILE" 2>&1 &
        seatd_pid=$!

        # Wait for the socket to appear (up to 5 seconds)
        i=0
        while [ "$i" -lt 100 ]; do
            if [ -S /run/seatd.sock ]; then
                log "seatd socket ready"
                return 0
            fi
            # Check if seatd died
            if ! kill -0 "$seatd_pid" 2>/dev/null; then
                log "seatd exited unexpectedly"
                return 1
            fi
            i=$((i + 1))
            sleep 0.05
        done
        log "seatd socket timeout"
        return 1
    fi
    log "seatd not found"
    return 1
}

wait_for_wayland_socket() {
    pid="$1"
    i=0
    while [ "$i" -lt 50 ]; do
        for s in "${XDG_RUNTIME_DIR}"/wayland-*; do
            [ -S "$s" ] || continue
            WAYLAND_SOCK="$s"
            export WAYLAND_DISPLAY="$(basename "$WAYLAND_SOCK")"
            return 0
        done
        kill -0 "$pid" 2>/dev/null || return 1
        i=$((i + 1))
        sleep 0.1
    done
    return 1
}

start_session_components() {
    compositor="$1"

    # Ensure a session bus exists (many desktop-ish apps expect it).
    if [ -z "${DBUS_SESSION_BUS_ADDRESS:-}" ] && command -v dbus-daemon >/dev/null 2>&1; then
        eval "$(dbus-daemon --session --fork --print-address 2>/dev/null | sed 's/^/export DBUS_SESSION_BUS_ADDRESS=/' )" || true
    fi

    case "$compositor" in
        weston*)
            if command -v weston-terminal >/dev/null 2>&1; then
                log "Autostart: weston-terminal"
                weston-terminal >>"$LOGFILE" 2>&1 &
            elif command -v foot >/dev/null 2>&1; then
                log "Autostart: foot"
                foot >>"$LOGFILE" 2>&1 &
            elif command -v alacritty >/dev/null 2>&1; then
                log "Autostart: alacritty"
                alacritty >>"$LOGFILE" 2>&1 &
            fi
            ;;
        hyprland*|Hyprland*)
            if command -v foot >/dev/null 2>&1; then
                log "Autostart: foot"
                foot >>"$LOGFILE" 2>&1 &
            elif command -v alacritty >/dev/null 2>&1; then
                log "Autostart: alacritty"
                alacritty >>"$LOGFILE" 2>&1 &
            fi
            ;;
        raven-compositor*)
            # Raven compositor is still early; clients may not be visible yet.
            log "Note: Raven compositor shell components are not implemented yet."
            ;;
    esac
}

start_compositor() {
    name="$1"
    shift
    log "Starting ${name}..."
    # Run compositor, logging to both file and serial
    if [ -c "$SERIAL" ]; then
        "$@" 2>&1 | tee -a "$LOGFILE" "$SERIAL" &
    else
        "$@" >>"$LOGFILE" 2>&1 &
    fi
    pid=$!

    if wait_for_wayland_socket "$pid"; then
        log "${name} started (WAYLAND_DISPLAY=${WAYLAND_DISPLAY:-unknown})"
        start_session_components "$name"
        wait "$pid"
        return $?
    fi

    if ! kill -0 "$pid" 2>/dev/null; then
        wait "$pid" || rc=$?
        rc="${rc:-0}"
        log "${name} exited early (rc=${rc}); see $LOGFILE"
        return 1
    fi

    log "${name} did not create a Wayland socket (see $LOGFILE)"
    kill "$pid" 2>/dev/null || true
    wait "$pid" 2>/dev/null || rc=$?
    rc="${rc:-0}"
    log "${name} stopped (rc=${rc})"
    return 1
}

if [ ! -d /dev/dri ]; then
    log "No /dev/dri found; DRM/KMS not available for a TTY Wayland compositor."
    log "Kernel: $(uname -a 2>/dev/null || true)"
    log "cmdline: $(cat /proc/cmdline 2>/dev/null || true)"
    log "Mounts:"
    mount 2>/dev/null | tee -a "$LOGFILE" || true
    log "Devices under /dev:"
    ls -la /dev 2>&1 | tee -a "$LOGFILE" || true
    log "DRM sysfs (/sys/class/drm):"
    ls -la /sys/class/drm 2>&1 | tee -a "$LOGFILE" || true
    log "dmesg (DRM/GPU):"
    dmesg 2>/dev/null | grep -iE 'drm|kms|gpu|i915|amdgpu|nouveau|virtio|vmwgfx|vbox|qxl|bochs|cirrus|simpledrm|framebuffer' | tail -n 200 | tee -a "$LOGFILE" || true
    log "In QEMU, try a KMS GPU (e.g. -device virtio-vga-gl -display gtk,gl=on)."
    exit 1
fi

start_seatd || true

preferred="${RAVEN_WAYLAND_COMPOSITOR:-}"
if [ -z "$preferred" ]; then
    if [ -n "${wayland_choice:-}" ]; then
        preferred="$wayland_choice"
    elif command -v raven-compositor >/dev/null 2>&1; then
        # Prefer raven-compositor when available
        preferred="raven-compositor"
    elif command -v weston >/dev/null 2>&1; then
        preferred="weston"
    else
        preferred="raven-compositor"
    fi
fi

log "cmdline: ${cmdline}"
log "raven.wayland: ${wayland_choice:-<unset>}"
log "Preferred compositor: $preferred"
log "Available DRM devices:"
ls -la /dev/dri/ 2>&1 | tee -a "$LOGFILE" || true
if [ -d /sys/class/drm ]; then
    log "DRM connector status:"
    found_connector=0
    have_connected=0
    for status in /sys/class/drm/*/status; do
        [ -f "$status" ] || continue
        connector="$(basename "$(dirname "$status")")"
        case "$connector" in
            card*|renderD*) continue ;;
        esac
        found_connector=1
        state="$(cat "$status" 2>/dev/null || true)"
        log "  ${connector}: ${state}"
        [ "$state" = "connected" ] && have_connected=1
    done
    if [ "$found_connector" -eq 1 ] && [ "$have_connected" -eq 0 ]; then
        log "No connected DRM outputs detected; DRM compositors won't have display modes."
        log "In QEMU, avoid -nographic/-display none, or use VNC/SPICE. Example: -device virtio-vga-gl -display gtk,gl=on"

        # Auto-set RAVEN_FORCE_MODE for VM environments without connected displays
        if [ -z "${RAVEN_FORCE_MODE:-}" ]; then
            # Check if running in a VM
            is_vm=0
            [ -d /sys/hypervisor ] && is_vm=1
            if [ -f /sys/class/dmi/id/sys_vendor ]; then
                vendor="$(cat /sys/class/dmi/id/sys_vendor 2>/dev/null | tr '[:upper:]' '[:lower:]')"
                case "$vendor" in
                    *qemu*|*kvm*|*vmware*|*virtualbox*|*xen*|*microsoft*) is_vm=1 ;;
                esac
            fi
            grep -q "hypervisor" /proc/cpuinfo 2>/dev/null && is_vm=1

            if [ "$is_vm" -eq 1 ]; then
                export RAVEN_FORCE_MODE="1024x768"
                log "VM detected with no connected display. Setting RAVEN_FORCE_MODE=1024x768"
                log "Set RAVEN_FORCE_MODE=WxH to use a different resolution."
            fi
        fi
    fi
fi

tried_hypr=0
tried_weston=0
tried_raven=0

start_raven_compositor() {
    tried_raven=1
    start_compositor "raven-compositor" raven-compositor && return 0
    log "Retrying raven-compositor with SMITHAY_USE_LEGACY=1..."
    start_compositor "raven-compositor (legacy)" env SMITHAY_USE_LEGACY=1 raven-compositor && return 0
    return 1
}

start_hyprland() {
    tried_hypr=1
    if command -v Hyprland >/dev/null 2>&1; then
        start_compositor "Hyprland" Hyprland && return 0
    fi
    if command -v hyprland >/dev/null 2>&1; then
        start_compositor "hyprland" hyprland && return 0
    fi
    return 1
}

start_weston() {
    tried_weston=1
    have_xwayland=0
    if command -v Xwayland >/dev/null 2>&1; then
        for m in /usr/lib/libweston-*/xwayland.so /usr/lib64/libweston-*/xwayland.so; do
            [ -f "$m" ] && have_xwayland=1 && break
        done
    fi

    weston_config=""
    [ -f /etc/xdg/weston/weston.ini ] && weston_config="--config=/etc/xdg/weston/weston.ini"

    if [ "$have_xwayland" -eq 1 ]; then
        # Avoid passing --tty to weston: some setups end up forwarding it to Xwayland, which then exits.
        start_compositor "weston" weston ${weston_config} --backend=drm-backend.so --xwayland && return 0
    else
        start_compositor "weston" weston ${weston_config} --backend=drm-backend.so && return 0
    fi
    log "Retrying weston with --renderer=pixman..."
    if [ "$have_xwayland" -eq 1 ]; then
        start_compositor "weston (pixman)" weston ${weston_config} --backend=drm-backend.so --renderer=pixman --xwayland && return 0
    else
        start_compositor "weston (pixman)" weston ${weston_config} --backend=drm-backend.so --renderer=pixman && return 0
    fi
    return 1
}

case "$preferred" in
    hyprland|Hyprland)
        start_hyprland && exit 0
        ;;
    weston)
        if command -v weston >/dev/null 2>&1; then
            start_weston && exit 0
        fi
        ;;
    raven-compositor|raven)
        if command -v raven-compositor >/dev/null 2>&1; then
            start_raven_compositor && exit 0
        fi
        ;;
esac

# Fallback order
if [ "$tried_hypr" -eq 0 ] && ( command -v Hyprland >/dev/null 2>&1 || command -v hyprland >/dev/null 2>&1 ); then
    start_hyprland && exit 0
fi
if [ "$tried_weston" -eq 0 ] && command -v weston >/dev/null 2>&1; then
    start_weston && exit 0
fi
if [ "$tried_raven" -eq 0 ] && command -v raven-compositor >/dev/null 2>&1; then
    start_raven_compositor && exit 0
fi

log "No Wayland compositor found (expected 'Hyprland', 'raven-compositor' or 'weston')."
exit 127
