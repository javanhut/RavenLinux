#!/bin/sh
set -eu

export PATH=/bin:/sbin:/usr/bin:/usr/sbin

LOGFILE="/run/raven-wayland-session.log"
SERIAL="/dev/ttyS0"
mkdir -p /run 2>/dev/null || true
printf '' >"$LOGFILE" 2>/dev/null || true

log() {
    printf '%s\n' "$*" | tee -a "$LOGFILE"
    # Also log to serial console if available
    [ -c "$SERIAL" ] && printf '%s\n' "$*" > "$SERIAL" 2>/dev/null || true
}

export XDG_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/run/user/0}"
_old_umask="$(umask)"
umask 077
mkdir -p "$XDG_RUNTIME_DIR" 2>/dev/null || true
umask "$_old_umask"

export LIBSEAT_BACKEND="${LIBSEAT_BACKEND:-seatd}"
export RUST_BACKTRACE="${RUST_BACKTRACE:-1}"
export FONTCONFIG_PATH="${FONTCONFIG_PATH:-/etc/fonts}"
export FONTCONFIG_FILE="${FONTCONFIG_FILE:-/etc/fonts/fonts.conf}"
export XCURSOR_PATH="${XCURSOR_PATH:-/usr/share/icons}"
if [ -z "${XCURSOR_THEME:-}" ]; then
    if [ -d /usr/share/icons/breeze_cursors ]; then
        export XCURSOR_THEME=breeze_cursors
    elif [ -d /usr/share/icons/Adwaita ]; then
        export XCURSOR_THEME=Adwaita
    fi
fi
export XCURSOR_SIZE="${XCURSOR_SIZE:-24}"
export SHELL="${SHELL:-/bin/bash}"

# Xwayland expects /tmp/.X11-unix to exist (it may not create the parent dir).
mkdir -p /tmp/.X11-unix 2>/dev/null || true
chmod 1777 /tmp /tmp/.X11-unix 2>/dev/null || true
rm -f /tmp/.X11-unix/X0 2>/dev/null || true

# Help libxkbcommon find keyboard layouts on minimal images.
# Some builds expect /usr/share/xkeyboard-config-2; others use /usr/share/X11/xkb.
if [ ! -e /usr/share/xkeyboard-config-2 ] && [ -d /usr/share/X11/xkb ]; then
    ln -sf X11/xkb /usr/share/xkeyboard-config-2 2>/dev/null || true
fi
if [ -z "${XKB_CONFIG_ROOT:-}" ]; then
    if [ -d /usr/share/xkeyboard-config-2 ]; then
        export XKB_CONFIG_ROOT=/usr/share/xkeyboard-config-2
    elif [ -d /usr/share/X11/xkb ]; then
        export XKB_CONFIG_ROOT=/usr/share/X11/xkb
    elif [ -d /usr/share/xkeyboard-config ]; then
        export XKB_CONFIG_ROOT=/usr/share/xkeyboard-config
    fi
fi

cmdline="$(cat /proc/cmdline 2>/dev/null || true)"
wayland_choice=""
for arg in $cmdline; do
    case "$arg" in
        raven.wayland=*)
            wayland_choice="${arg#raven.wayland=}"
            break
            ;;
    esac
done

start_seatd() {
    # Check if seatd is already running
    if [ -S /run/seatd.sock ]; then
        log "seatd already running"
        return 0
    fi

    if command -v seatd >/dev/null 2>&1; then
        log "Starting seatd..."
        # Run seatd with video group access
        seatd -g video >>"$LOGFILE" 2>&1 &
        seatd_pid=$!

        # Wait for the socket to appear (up to 5 seconds)
        i=0
        while [ "$i" -lt 100 ]; do
            if [ -S /run/seatd.sock ]; then
                log "seatd socket ready"
                return 0
            fi
            # Check if seatd died
            if ! kill -0 "$seatd_pid" 2>/dev/null; then
                log "seatd exited unexpectedly"
                return 1
            fi
            i=$((i + 1))
            sleep 0.05
        done
        log "seatd socket timeout"
        return 1
    fi
    log "seatd not found"
    return 1
}

wait_for_wayland_socket() {
    pid="$1"
    i=0
    while [ "$i" -lt 50 ]; do
        for s in "${XDG_RUNTIME_DIR}"/wayland-*; do
            [ -S "$s" ] || continue
            WAYLAND_SOCK="$s"
            export WAYLAND_DISPLAY="$(basename "$WAYLAND_SOCK")"
            return 0
        done
        kill -0 "$pid" 2>/dev/null || return 1
        i=$((i + 1))
        sleep 0.1
    done
    return 1
}

start_session_components() {
    compositor="$1"

    # Ensure a session bus exists (many desktop-ish apps expect it).
    if [ -z "${DBUS_SESSION_BUS_ADDRESS:-}" ] && command -v dbus-daemon >/dev/null 2>&1; then
        eval "$(dbus-daemon --session --fork --print-address 2>/dev/null | sed 's/^/export DBUS_SESSION_BUS_ADDRESS=/' )" || true
    fi

    # Set up DISPLAY for XWayland if X socket exists
    # This allows X11/GLFW apps to work through XWayland
    if [ -z "${DISPLAY:-}" ]; then
        # Wait briefly for XWayland to create the socket
        i=0
        while [ "$i" -lt 20 ]; do
            if [ -S /tmp/.X11-unix/X0 ]; then
                export DISPLAY=:0
                log "XWayland detected, DISPLAY=:0"
                break
            fi
            i=$((i + 1))
            sleep 0.1
        done
    fi

    # -------------------------------------------------------------------------
    # Start user session services (audio, portals)
    # -------------------------------------------------------------------------

    # PipeWire audio server
    if command -v pipewire >/dev/null 2>&1; then
        log "Starting PipeWire..."
        pipewire >>"$LOGFILE" 2>&1 &
        sleep 0.1
    fi

    # WirePlumber session manager (after pipewire)
    if command -v wireplumber >/dev/null 2>&1; then
        log "Starting WirePlumber..."
        wireplumber >>"$LOGFILE" 2>&1 &
    fi

    # PipeWire PulseAudio compatibility
    if command -v pipewire-pulse >/dev/null 2>&1; then
        log "Starting PipeWire-Pulse..."
        pipewire-pulse >>"$LOGFILE" 2>&1 &
    fi

    # XDG Desktop Portal (for file dialogs, screen sharing)
    if [ -x /usr/libexec/xdg-desktop-portal ]; then
        log "Starting XDG Desktop Portal..."
        /usr/libexec/xdg-desktop-portal >>"$LOGFILE" 2>&1 &
    fi

    # XDG Desktop Portal Hyprland backend
    if [ -x /usr/libexec/xdg-desktop-portal-hyprland ]; then
        log "Starting XDG Desktop Portal Hyprland..."
        /usr/libexec/xdg-desktop-portal-hyprland >>"$LOGFILE" 2>&1 &
    fi

    # -------------------------------------------------------------------------
    # Compositor-specific autostart
    # -------------------------------------------------------------------------

    case "$compositor" in
        hyprland*|Hyprland*)
            # Hyprland handles app autostart via hyprland.conf exec-once
            log "Hyprland handles app autostart via config"
            ;;
        *)
            # Fallback for any other compositor
            if command -v raven-desktop >/dev/null 2>&1; then
                log "Autostart: raven-desktop"
                raven-desktop >>"$LOGFILE" 2>&1 &
            fi
            if command -v raven-shell >/dev/null 2>&1; then
                log "Autostart: raven-shell (panel)"
                sleep 0.2
                raven-shell >>"$LOGFILE" 2>&1 &
            fi
            if command -v raven-terminal >/dev/null 2>&1; then
                log "Autostart: raven-terminal"
                sleep 0.5
                raven-terminal >>"$LOGFILE" 2>&1 &
            fi
            ;;
    esac
}

start_compositor() {
    name="$1"
    shift
    log "Starting ${name}..."
    # Run compositor, logging to both file and serial
    if [ -c "$SERIAL" ]; then
        "$@" 2>&1 | tee -a "$LOGFILE" "$SERIAL" &
    else
        "$@" >>"$LOGFILE" 2>&1 &
    fi
    pid=$!

    if wait_for_wayland_socket "$pid"; then
        log "${name} started (WAYLAND_DISPLAY=${WAYLAND_DISPLAY:-unknown})"
        start_session_components "$name"
        wait "$pid"
        return $?
    fi

    if ! kill -0 "$pid" 2>/dev/null; then
        wait "$pid" || rc=$?
        rc="${rc:-0}"
        log "${name} exited early (rc=${rc}); see $LOGFILE"
        return 1
    fi

    log "${name} did not create a Wayland socket (see $LOGFILE)"
    kill "$pid" 2>/dev/null || true
    wait "$pid" 2>/dev/null || rc=$?
    rc="${rc:-0}"
    log "${name} stopped (rc=${rc})"
    return 1
}

if [ ! -d /dev/dri ]; then
    log "No /dev/dri found; DRM/KMS not available for a TTY Wayland compositor."
    log "Kernel: $(uname -a 2>/dev/null || true)"
    log "cmdline: $(cat /proc/cmdline 2>/dev/null || true)"
    log "Mounts:"
    mount 2>/dev/null | tee -a "$LOGFILE" || true
    log "Devices under /dev:"
    ls -la /dev 2>&1 | tee -a "$LOGFILE" || true
    log "DRM sysfs (/sys/class/drm):"
    ls -la /sys/class/drm 2>&1 | tee -a "$LOGFILE" || true
    log "dmesg (DRM/GPU):"
    dmesg 2>/dev/null | grep -iE 'drm|kms|gpu|i915|amdgpu|nouveau|virtio|vmwgfx|vbox|qxl|bochs|cirrus|simpledrm|framebuffer' | tail -n 200 | tee -a "$LOGFILE" || true
    log "In QEMU, try a KMS GPU (e.g. -device virtio-vga-gl -display gtk,gl=on)."
    exit 1
fi

start_seatd || true

preferred="${RAVEN_WAYLAND_COMPOSITOR:-}"
if [ -z "$preferred" ]; then
    if [ -n "${wayland_choice:-}" ]; then
        preferred="$wayland_choice"
    else
        # Default to Hyprland
        preferred="Hyprland"
    fi
fi

log "cmdline: ${cmdline}"
log "raven.wayland: ${wayland_choice:-<unset>}"
log "Preferred compositor: $preferred"
log "Available DRM devices:"
ls -la /dev/dri/ 2>&1 | tee -a "$LOGFILE" || true
if [ -d /sys/class/drm ]; then
    log "DRM connector status:"
    found_connector=0
    have_connected=0
    for status in /sys/class/drm/*/status; do
        [ -f "$status" ] || continue
        connector="$(basename "$(dirname "$status")")"
        case "$connector" in
            card*|renderD*) continue ;;
        esac
        found_connector=1
        state="$(cat "$status" 2>/dev/null || true)"
        log "  ${connector}: ${state}"
        [ "$state" = "connected" ] && have_connected=1
    done
    if [ "$found_connector" -eq 1 ] && [ "$have_connected" -eq 0 ]; then
        log "No connected DRM outputs detected; DRM compositors won't have display modes."
        log "In QEMU, avoid -nographic/-display none, or use VNC/SPICE. Example: -device virtio-vga-gl -display gtk,gl=on"

        # Auto-set RAVEN_FORCE_MODE for VM environments without connected displays
        if [ -z "${RAVEN_FORCE_MODE:-}" ]; then
            # Check if running in a VM
            is_vm=0
            [ -d /sys/hypervisor ] && is_vm=1
            if [ -f /sys/class/dmi/id/sys_vendor ]; then
                vendor="$(cat /sys/class/dmi/id/sys_vendor 2>/dev/null | tr '[:upper:]' '[:lower:]')"
                case "$vendor" in
                    *qemu*|*kvm*|*vmware*|*virtualbox*|*xen*|*microsoft*) is_vm=1 ;;
                esac
            fi
            grep -q "hypervisor" /proc/cpuinfo 2>/dev/null && is_vm=1

            if [ "$is_vm" -eq 1 ]; then
                export RAVEN_FORCE_MODE="1024x768"
                log "VM detected with no connected display. Setting RAVEN_FORCE_MODE=1024x768"
                log "Set RAVEN_FORCE_MODE=WxH to use a different resolution."
            fi
        fi
    fi
fi

tried_hypr=0

start_hyprland() {
    tried_hypr=1
    # Hyprland requires --i-am-really-stupid flag when running as root (UID 0)
    hypr_args=""
    [ "$(id -u)" -eq 0 ] && hypr_args="--i-am-really-stupid"

    if command -v Hyprland >/dev/null 2>&1; then
        start_compositor "Hyprland" Hyprland $hypr_args && return 0
    fi
    if command -v hyprland >/dev/null 2>&1; then
        start_compositor "hyprland" hyprland $hypr_args && return 0
    fi
    return 1
}

case "$preferred" in
    hyprland|Hyprland)
        start_hyprland && exit 0
        ;;
esac

# Fallback: try Hyprland
if [ "$tried_hypr" -eq 0 ] && ( command -v Hyprland >/dev/null 2>&1 || command -v hyprland >/dev/null 2>&1 ); then
    start_hyprland && exit 0
fi

log "No Wayland compositor found (expected 'Hyprland')."
exit 127
